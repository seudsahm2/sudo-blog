# make_sqlite_seed.py
# Generates SQLite-compatible SQL for: auth_user, blog_category, blog_tag, blog_post, blog_post_tags (M2M), blog_comment, blog_like
# Usage: python make_sqlite_seed.py
# Then import with: sqlite3 db.sqlite3 < blog_seed_sqlite.sql

import random
import hashlib
from datetime import datetime, timedelta, timezone
import os

OUT_FILENAME = "blog_seed_sqlite.sql"   # output SQL file
NUM_USERS = 1000
NUM_CATEGORIES = 1000
NUM_TAGS = 1000
NUM_POSTS = 1000
NUM_COMMENTS = 1000
NUM_LIKES = 1000
# M2M links: we will create roughly (on avg) 2 tags per post -> adjust multiplier if you want more
AVG_TAGS_PER_POST = 2

random.seed(42)
now = datetime.now(timezone.utc)

def safe_sql_string(s):
    """Escape single quotes for SQL."""
    return s.replace("'", "''")

def iso(dt):
    """Format datetime for SQLite."""
    return dt.strftime("%Y-%m-%d %H:%M:%S")

# IMPORTANT: default Django M2M table for Post.tags is "<app_label>_post_tags"
# For app "blog" and model "Post" field "tags" Django creates "blog_post_tags".
# If you customized app_label or field name, update M2M_TABLE accordingly.
M2M_TABLE = "blog_post_tags"   # table to insert post-tag relations (columns we will reference: id, post_id, tag_id)

with open(OUT_FILENAME, "w", encoding="utf-8") as f:
    f.write("-- SQLite seed SQL generated by make_sqlite_seed.py\n")
    f.write("-- Ensure you ran `python manage.py migrate` before importing this file.\n\n")

    # Users
    f.write("-- auth_user rows\n")
    for i in range(1, NUM_USERS + 1):
        username = f"user{i}"
        email = f"user{i}@example.com"
        password = "pbkdf2_sha256$260000$" + hashlib.md5(username.encode()).hexdigest()
        is_super = 1 if i == 1 else 0
        is_staff = 1 if i <= 10 else 0
        is_active = 1
        date_joined = iso(now - timedelta(days=random.randint(0, 1000)))
        first_name = f"First{i}"
        last_name = f"Last{i}"
        f.write(
            "INSERT INTO auth_user (id, password, last_login, is_superuser, username, first_name, last_name, email, is_staff, is_active, date_joined) VALUES "
            f"({i}, '{safe_sql_string(password)}', NULL, {is_super}, '{safe_sql_string(username)}', '{safe_sql_string(first_name)}', '{safe_sql_string(last_name)}', '{safe_sql_string(email)}', {is_staff}, {is_active}, '{date_joined}');\n"
        )
    f.write("\n")

    # Categories
    f.write("-- blog_category rows\n")
    for i in range(1, NUM_CATEGORIES + 1):
        name = f"Category {i}"
        slug = f"category-{i}"
        f.write(f"INSERT INTO blog_category (id, name, slug) VALUES ({i}, '{safe_sql_string(name)}', '{safe_sql_string(slug)}');\n")
    f.write("\n")

    # Tags
    f.write("-- blog_tag rows\n")
    for i in range(1, NUM_TAGS + 1):
        name = f"Tag {i}"
        slug = f"tag-{i}"
        f.write(f"INSERT INTO blog_tag (id, name, slug) VALUES ({i}, '{safe_sql_string(name)}', '{safe_sql_string(slug)}');\n")
    f.write("\n")

    # Posts (now include category_id)
    f.write("-- blog_post rows\n")
    for i in range(1, NUM_POSTS + 1):
        title = f"Seeded Post {i}"
        slug = f"seeded-post-{i}"
        author_id = random.randint(1, NUM_USERS)
        # randomly assign a category or leave null (10% uncategorized)
        if random.random() < 0.9:
            category_id = random.randint(1, NUM_CATEGORIES)
            category_val = str(category_id)
        else:
            category_val = "NULL"
        body = ("This is the seeded body for post " + str(i) + ". ") * (1 + (i % 5))
        publish_dt = now - timedelta(days=random.randint(-30, 720), hours=random.randint(0, 23), minutes=random.randint(0, 59))
        created_dt = publish_dt - timedelta(days=random.randint(0, 30))
        updated_dt = created_dt + timedelta(days=random.randint(0, 30))
        status = "PB" if random.random() < 0.65 else "DF"
        # Insert with category_id possibly NULL
        f.write(
            "INSERT INTO blog_post (id, title, slug, author_id, body, publish, created, updated, status, category_id) VALUES "
            f"({i}, '{safe_sql_string(title)}', '{safe_sql_string(slug)}', {author_id}, '{safe_sql_string(body)}', '{iso(publish_dt)}', '{iso(created_dt)}', '{iso(updated_dt)}', '{status}', {category_val});\n"
        )
    f.write("\n")

    # M2M: blog_post_tags (post_id, tag_id) â€” generate relationships
    f.write("-- M2M blog_post_tags rows (post_id, tag_id)\n")
    m2m_id = 1
    # we will assign approx AVG_TAGS_PER_POST tags to each post (may overlap)
    for post_id in range(1, NUM_POSTS + 1):
        num_tags = random.poissonvariate if False else (AVG_TAGS_PER_POST + (1 if random.random() < 0.3 else 0))  # simple distribution
        # choose unique tags for this post
        chosen = set()
        attempts = 0
        while len(chosen) < num_tags and attempts < 20:
            attempts += 1
            t = random.randint(1, NUM_TAGS)
            if t in chosen:
                continue
            chosen.add(t)
            # insert with explicit id for safe import
            f.write(
                f"INSERT INTO {M2M_TABLE} (id, post_id, tag_id) VALUES ({m2m_id}, {post_id}, {t});\n"
            )
            m2m_id += 1
    f.write("\n")

    # Comments
    f.write("-- blog_comment rows\n")
    for i in range(1, NUM_COMMENTS + 1):
        post_id = ((i - 1) % NUM_POSTS) + 1
        user_id = random.randint(1, NUM_USERS)
        body = f"Seed comment {i} on post {post_id}."
        created_dt = now - timedelta(days=random.randint(0, 900), hours=random.randint(0, 23), minutes=random.randint(0, 59))
        updated_dt = created_dt + timedelta(hours=random.randint(0, 200))
        approved = 1 if random.random() < 0.5 else 0
        f.write(
            "INSERT INTO blog_comment (id, post_id, user_id, body, created, updated, approved) VALUES "
            f"({i}, {post_id}, {user_id}, '{safe_sql_string(body)}', '{iso(created_dt)}', '{iso(updated_dt)}', {approved});\n"
        )
    f.write("\n")

    # Likes (unique pair generation)
    f.write("-- blog_like rows\n")
    likes_set = set()
    like_id = 1
    attempts = 0
    max_attempts = NUM_LIKES * 10
    while like_id <= NUM_LIKES and attempts < max_attempts:
        attempts += 1
        post_id = random.randint(1, NUM_POSTS)
        user_id = random.randint(1, NUM_USERS)
        pair = (post_id, user_id)
        if pair in likes_set:
            continue
        likes_set.add(pair)
        created_dt = now - timedelta(days=random.randint(0, 900), hours=random.randint(0, 23), minutes=random.randint(0, 59))
        f.write(
            "INSERT INTO blog_like (id, post_id, user_id, created) VALUES "
            f"({like_id}, {post_id}, {user_id}, '{iso(created_dt)}');\n"
        )
        like_id += 1

    f.write("\n-- End of seed SQL\n")

print(f"Done. Wrote {OUT_FILENAME} with seed data (users:{NUM_USERS}, categories:{NUM_CATEGORIES}, tags:{NUM_TAGS}, posts:{NUM_POSTS}, comments:{NUM_COMMENTS}, likes:{len(likes_set)}, m2m_rows:{m2m_id-1})")
